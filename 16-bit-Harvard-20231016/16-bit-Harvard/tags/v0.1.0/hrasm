#! /usr/bin/perl
#------------------------------------------------------------------------------
#$Author: saulius $
#$Date: 2020-09-03 11:51:18 +0300 (Thu, 03 Sep 2020) $ 
#$Revision: 1208 $
#$URL: svn+ssh://saulius-grazulis.lt/home/saulius/svn-repositories/tests/logisim/AM2016/amasm $
#------------------------------------------------------------------------------
#*
# ISA assembler for the AM „KA“ 2016 book. Outputs ROM suitable for
# Logisim.

# USAGE:
#   $0 program.asm
#   $0 program.asm | (echo 'v2.0 raw'; awk '{print $1}') > program.ram

# INPUT: An assembler program for the AM „KA“ 2016 theoretical computer:
#
#        JMP START
# X:     DW  12
# Y:     DW  10
# START: LDC 20
#        LD  X
#        ADD Y
#        ST  Z

# OUTPUT:

# A HEX number list with the assembled program.

#**

use strict;
use warnings;

my $Id = '$Id: amasm 1208 2020-09-03 08:51:18Z saulius $';

my %one_addr_opcodes = (
    LDC     => 2,
    LD      => 3,
    ST      => 4,
    IN      => 5,
    OUT     => 6,
    JMP     => 7,
    JNZ     => 8,
    JPOS    => 9,
    JNEG    => 10,
    ADD     => 11,
    SUB     => 12,
    MUL     => 13,
    DIV     => 14,
    REM     => 15,
    SHL     => 16,
    SHR     => 17,
    NEG     => 18,
    ROTL    => 19,
    ROTR    => 20,
    SAR     => 21,
    AND     => 22,
    OR      => 23,
    XOR     => 24,
    ADDC    => 25,
    SUBC    => 26,
    MULC    => 27,
    DIVC    => 28,
    REMC    => 29,
    ANDC    => 30,
    ORC     => 31,
    XORC    => 32,
    LDXC    => 41,
    LDX     => 42,
);

my %zero_addr_opcodes = (
    NOP => 0,
    HALT => 0xFF,
    NOP     => 0,
    LDI     => 1,
    ADDX    => 33,
    SUBX    => 34,
    MULX    => 35,
    DIVX    => 36,
    REMX    => 37,
    ANDX    => 38,
    ORX     => 39,
    XORX    => 40,
    ATOX    => 43,
    XTOA    => 44,
    INCX    => 45,
    STI     => 46,
    APLUSX  => 47,
    AMINUSX => 48,
);

# Programs are small, we can "slurp":

my @code = grep !/^\s*[\#*;]|^\s*$/, <>;

do {
    local $, = " ";
    print STDERR @code;
} if 0;

my %labels;

my $address = 0;
my $line = 1;
for (@code) {
    chomp;
    s/^\s*//;
    if( s/^([a-zA-Z0-9]+):\s*// ) {
        my $label = $1;
        if( exists $labels{$label} ) {
            warn "label '$label' redefined from $labels{$label} to $address";
        }
        if( /^EQU\s/ ) {
            my @line = split;
            if( @line < 2 ) {
                die "need a label or a number after 'EQU' in line $line ('$_')";
            } else {
                if( $line[1] =~ /^[-+]?\d+$/ ) {
                    $labels{$label} = $line[1];
                } else {
                    if( exists $labels{$line[1]} ) {
                        $labels{$label} = $labels{$line[1]}
                    } else {
                        warn "undefined label '$line[1]' for EQU, assuming 0";
                        $labels{$label} = 0;
                    }
                }
            }
            $address --;
        } else {
            $labels{$label} = $address;
        }
    }
    $address ++;
    $line ++;
}

do {
    local $, = " ";
    local $\ = "\n";
    print STDERR @code;
} if 0;

do {
    local $\ = "\n";
    local $, = " ";
    print STDERR %labels;
} if 0;

# Assemble:

my $bitwidth = 24;
my $addrwidth = 16;

$line = 1;
for (@code) {
    my @line = split;
    my $opcode = $line[0];
    if( /^\s*(?:;.*)?$/ ) {
        $line++;
        next;
    }
    if( $opcode eq 'DW' ) {
        my $printval = $line[1] & ((1<<$bitwidth) - 1);
        printf "%06X\n", $printval;
    } elsif( $opcode eq 'EQU' ) {
        # skip
    } elsif( exists $one_addr_opcodes{$opcode} ) {
        if( @line < 2 ) {
            die "need a label or a number after '$opcode' in line $line ('$_')";
        } else {
            my $operand = $line[1];
            my $value;
            if( $operand =~ /^[-+]?\d+$/ ) {
                $value = $operand & ((1<<$addrwidth) - 1)
            } elsif( exists $labels{$operand} ) {
                $value = $labels{$operand}
            } else {
                die "undefined label '$operand' in line $line ('$_')";
            }
            my $instruction = 
                ($one_addr_opcodes{$opcode} << $addrwidth) | $value;
            printf "%06X\n", $instruction;
        }
    } elsif( exists $zero_addr_opcodes{$opcode} ) {
        if( $opcode eq "HALT" ) {
            printf "%06X\n", ($zero_addr_opcodes{$opcode} << 16) | 0xFFFF;
        } else {
            printf "%06X\n", ($zero_addr_opcodes{$opcode} << 16);
        }
    } else {
        die "unknown opcode '$opcode' in line $line ('$_')";
    }
    $line ++;
}
